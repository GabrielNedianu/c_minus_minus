/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal 			INTEGER,BOOL,VOID,TRUE,FALSE,IF,ELSE,WHILE,RETURN,CIN,COUT;
terminal			QUATATIONMARK,EQ,PLUS,MINUS,TIMES,DIVISION,LEFTSHIFT,RIGHTSHIFT,LESS,GREATER,LESSEQ,GREATEREQ,EQEQ,NOTEQ;
terminal			OR,AND,NOT,LEFTCURLY,RIGHTCURLY,LEFT,RIGHT,LEFTSQ,RIGHTSQ,COMMA,SEMI;
terminal String 	IDENTIFIER;			  // identifer
terminal String		STRING;				  // string for our scanner
terminal Integer    INTEGER_VALUE;        // our scanner provides numbers as integers
terminal Boolean 	BOOLEAN_VALUE;		  // boolean values

/* Non terminals */


non terminal program, varDecl, fnDecl, type, parameters, block, formalsList, formalDecl, declList, stmtList, stmt, exp;
non terminal subscriptExpr, fnCallStmt, atom, fnCallExpr, actualList;

/* Precedences */
precedence left PLUS, MINUS;
precedence left TIMES, DIVISION;

/* The grammar rules */
program
	::= program varDecl				{: System.out.println("program-> Declaration List \n"); :}
	|	program fnDecl
	|	/* empty */
	;
	
varDecl
	::= type IDENTIFIER SEMI
	| type IDENTIFIER LEFTSQ INTEGER_VALUE RIGHTSQ SEMI
	;
	
type
	::= INTEGER	| BOOL | VOID;

fnDecl
	::= type IDENTIFIER parameters block
	;
	
parameters
	::= LEFT RIGHT
	| LEFT formalsList RIGHT
	;
	
formalsList
	::= formalDecl
	| formalsList COMMA formalDecl
	;
	
formalDecl
	::= type IDENTIFIER;
	
block
	::= LEFTCURLY declList stmtList RIGHTCURLY	;
	
declList
	::= declList varDecl
	| /* empty */
;

stmtList
	::= stmtList stmt
	| /* empty */
	;
	
stmt
	::= CIN RIGHTSHIFT IDENTIFIER COMMA
	| CIN RIGHTSHIFT IDENTIFIER LEFTSQ exp RIGHTSQ COMMA
	| COUT LEFTSHIFT exp COMMA
	| subscriptExpr EQ exp COMMA
	| IDENTIFIER EQ exp COMMA
	| IF LEFT exp RIGHT block
	| IF LEFT exp RIGHT block ELSE block
	| WHILE LEFT exp RIGHT block
	| RETURN exp COMMA
	| RETURN COMMA
	| fnCallStmt COMMA
	;	

exp
	::= exp PLUS exp
	| exp MINUS exp
	| exp TIMES exp
	| exp DIVISION exp
	| NOT exp
	| exp AND exp
	| exp OR exp
	| exp EQEQ exp
	| exp NOTEQ exp
	| exp LESS exp
	| exp GREATER exp
	| exp LESSEQ exp
	| exp GREATEREQ exp
	| MINUS atom
	| atom
	;
	
atom
	::= INTEGER_VALUE
	| STRING
	| TRUE
	| FALSE
	| LEFT exp RIGHT
	| fnCallExpr
	| subscriptExpr
	| IDENTIFIER
	;
	
	
fnCallExpr
	::= IDENTIFIER RIGHT LEFT
	| IDENTIFIER RIGHT actualList LEFT
	;

fnCallStmt
	::= IDENTIFIER RIGHT LEFT
	| IDENTIFIER RIGHT actualList LEFT
	;
	
actualList
	::= exp
	| actualList COMMA exp
	;

subscriptExpr
	::= IDENTIFIER LEFTSQ exp RIGHTSQ
	;		


/* The grammar rules */
/* expr_list ::= expr_list expr:e SEMI         {: System.out.println(e); :}
            | expr:e SEMI                   {: System.out.println(e); :}
            ;
            
expr      ::= expr:e1 PLUS  expr:e2         {: RESULT = e1+e2;        :}
             | expr:e1 MINUS expr:e2        {: RESULT = e1-e2;        :}
             | expr:e1 TIMES expr:e2        {: RESULT = e1*e2;        :}
             | MINUS expr:e                 {: RESULT = -e;           :}
             ;
*/

