/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal  			INTEGER,BOOL,VOID,TRUE,FALSE,IF,ELSE,WHILE,RETURN,CIN,COUT;
terminal			QUATATIONMARK,EQ,PLUS,MINUS,TIMES,DIVISION,LEFTSHIFT,RIGHTSHIFT,LESS,GREATER,LESSEQ,GREATEREQ,EQEQ,NOTEQ;
terminal			OR,AND,NOT,LEFTCURLY,RIGHTCURLY,LEFT,RIGHT,LEFTSQ,RIGHTSQ,COMMA,SEMI;
terminal String 	IDENTIFIER;			  // identifer
terminal String		STRING;				  // string for our scanner
terminal Integer    INTEGER_VALUE;        // our scanner provides numbers as integers
terminal Boolean 	BOOLEAN_VALUE;		  // boolean values

/* Non terminals */


non terminal MultiTreeNode  program, varDecl, fnDecl, type, parameters, block, formalsList, formalDecl, declList, stmtList, stmt, exp;
non terminal MultiTreeNode  subscriptExpr, fnCallStmt, atom, fnCallExpr, actualList;

/* Precedences */
precedence left PLUS, MINUS;
precedence left TIMES, DIVISION;

/* The grammar rules */
program
	::= program:p varDecl:varD				{: RESULT = p; syntaxTree.addChildNode(varD); :}
	|	program:p fnDecl:fnD				{: RESULT = p; syntaxTree.addChildNode(fnD); :}
	|	/* empty */							{: RESULT = syntaxTree.create("Program"); :}
	;
	
varDecl
	::= type:t IDENTIFIER:id SEMI											{: RESULT = createVarDeclaration(t, id, 0); :}	
	| type:t IDENTIFIER:id LEFTSQ INTEGER_VALUE:val RIGHTSQ SEMI			{: RESULT = createVarArrDeclaration(t, id, val); :}	
	;
	
type
	::= INTEGER		{: RESULT = createTypeSpecifier("INTEGER"); :}
	| BOOL 			{: RESULT = createTypeSpecifier("BOOL"); :}
	| VOID			{: RESULT = createTypeSpecifier("VOID"); :}
	;

fnDecl
	::= type:t IDENTIFIER:id parameters:para block:blck		{: RESULT = createFunctionDeclarationNode(t, id, para, blck); :}
	;
	
parameters
	::= LEFT RIGHT									{: RESULT = createParameters(null); :}
	| LEFT formalsList:frmL RIGHT					{: RESULT = createParameters(frmL); :}
	;
	
formalsList
	::= formalDecl:frmD								{: RESULT = createListNode("Formals List", frmD); :}
	| formalsList:frmL COMMA formalDecl:frmD		{: RESULT = frml; RESULT.addChild(frmD); :}
	;
	
formalDecl
	::= type:t IDENTIFIER:id							{: RESULT = createVarDeclaration(t, id, null); :}
	;
	
block
	::= LEFTCURLY declList:dcL stmtList:stmtL RIGHTCURLY		{: RESULT = createBlock(dcL,stmtL); :}	
	;
	
declList
	::= declList:dcL varDecl:varD							{: RESULT = dcL; RESULT.addChild(varD); :}
	| /* empty */									{: RESULT = createListNode("Declarations List", null); :}
	;

stmtList
	::= stmtList stmt								{: RESULT = StmL; RESULT.addChild(stmt); :}	
	| /* empty */									{: RESULT = createListNode("Instructions List", null); :}
	;
	
stmt
	::= CIN RIGHTSHIFT IDENTIFIER SEMI						{: System.out.println("stmt -> CIN RIGHTSHIFT IDENTIFIER ; \n"); :}
	| CIN RIGHTSHIFT IDENTIFIER LEFTSQ exp RIGHTSQ SEMI		{: System.out.println("stmt -> CIN RIGHTSHIFT IDENTIFIER [ exp ] ; \n"); :}
	| COUT LEFTSHIFT exp SEMI								{: System.out.println("stmt -> COUT LEFTSHIFT exp ;\n"); :}
	| subscriptExpr EQ exp SEMI								{: System.out.println("stmt -> subscriptExpr EQ exp ;\n"); :}
	| IDENTIFIER EQ exp SEMI								{: System.out.println("stmt -> IDENTIFIER EQ exp ; \n"); :}
	| IF LEFT exp RIGHT block								{: System.out.println("stmt -> IF ( exp ) block\n"); :}
	| IF LEFT exp RIGHT block ELSE block					{: System.out.println("stmt -> IF ( exp ) block ELSE block \n"); :}
	| WHILE LEFT exp RIGHT block							{: System.out.println("stmt -> WHILE ( exp ) block\n"); :}
	| RETURN exp:e SEMI										{: RESULT = createStatement("Return", e); :}
	| RETURN SEMI											{: RESULT = createStatement("Return"); :}
	| fnCallStmt SEMI										{: System.out.println("stmt -> fnCallStmt ; \n"); :}
	;	

exp
	::= exp PLUS exp		{: System.out.println("exp -> exp PLUS exp \n"); :}
	| exp MINUS exp			{: System.out.println("exp -> exp MINUS exp \n"); :}
	| exp TIMES exp			{: System.out.println("exp -> exp TIMES exp \n"); :}
	| exp DIVISION exp		{: System.out.println("exp -> exp DIVISION exp \n"); :}
	| NOT exp				{: System.out.println("exp -> NOT exp \n"); :}
	| exp AND exp			{: System.out.println("exp -> exp AND exp \n"); :}
	| exp OR exp			{: System.out.println("exp -> exp OR exp \n"); :}
	| exp EQEQ exp			{: System.out.println("exp -> exp EQEQ exp \n"); :}
	| exp NOTEQ exp			{: System.out.println("exp -> exp NOTEQ exp \n"); :}
	| exp LESS exp			{: System.out.println("exp -> exp LESS exp \n"); :}
	| exp GREATER exp		{: System.out.println("exp -> exp GREATER exp \n"); :}
	| exp LESSEQ exp		{: System.out.println("exp -> exp LESSEQ exp \n"); :}
	| exp GREATEREQ exp		{: System.out.println("exp -> exp GREATEREQ exp \n"); :}
	| MINUS atom			{: System.out.println("exp -> MINUS atom \n"); :}
	| atom					{: System.out.println("exp -> atom \n"); :}
	;
	
atom
	::= INTEGER_VALUE	{: System.out.println("atom -> INTEGER_VALUE \n"); :}
	| STRING			{: System.out.println("atom -> STRING \n"); :}
	| BOOLEAN_VALUE		{: System.out.println("atom -> BOOLEAN_VALUE \n"); :}
	| LEFT exp RIGHT	{: System.out.println("atom -> ( exp ) \n"); :}
	| fnCallExpr		{: System.out.println("atom -> fnCallExpr \n"); :}
	| subscriptExpr		{: System.out.println("atom -> subscriptExpr \n"); :}
	| IDENTIFIER		{: System.out.println("atom -> IDENTIFIER \n"); :}
	;
	
	
fnCallExpr
	::= IDENTIFIER RIGHT LEFT				{: System.out.println("fnCallExpr -> IDENTIFIER ( ) \n"); :}
	| IDENTIFIER RIGHT actualList LEFT		{: System.out.println("fnCallExpr -> IDENTIFIER ( actualList ) \n"); :}
	;

fnCallStmt
	::= IDENTIFIER RIGHT LEFT				{: System.out.println("fnCallStmt ->  IDENTIFIER ( ) \n"); :}
	| IDENTIFIER RIGHT actualList LEFT		{: System.out.println("fnCallStmt ->  IDENTIFIER ( actualList ) \n"); :}
	;
	
actualList
	::= exp						{: System.out.println("actualList ->  exp \n"); :}
	| actualList COMMA exp		{: System.out.println("actualList ->  actualList COMMA exp \n"); :}
	;

subscriptExpr
	::= IDENTIFIER LEFTSQ exp RIGHTSQ		{: System.out.println("subscriptExpr ->  IDENTIFIER [ exp ] \n"); :}
	;		
